#include "LocalAssembling.h"
#include "ParameterDatabase.h"
#include "Saddle_point_preconditioner.h"
#ifdef __2D__
#include <Assemble2D.h>
#include <SquareMatrix2D.h>
#else
#include <Assemble3D.h>
#include <SquareMatrix3D.h>
#endif
#include "BaseCell.h"
#include <MainUtilities.h>
#include <MooNMD_Io.h>
#include <algorithm>

#include <BoundEdge.h>
#include <BoundFace.h>
#include <Chrono.h>
#include <Joint.h>

#include <BlockFEMatrix.h>

#ifdef _MPI
#include <ParFECommunicator3D.h>
#endif

// see https://stackoverflow.com/a/8016853
constexpr char Saddle_point_preconditioner::database_name[];
constexpr char Saddle_point_preconditioner::database_name_velocity_solver[];
constexpr char Saddle_point_preconditioner::database_name_pressure_solver[];


/* ************************************************************************** */
Saddle_point_preconditioner::Saddle_point_preconditioner(
    const BlockFEMatrix& m, type t, const ParameterDatabase& db,
    const BlockVector&)
  : spp_type(t), M(&m), velocity_block(), pressure_block(), pressure_mass(),
    gradient_block(nullptr), divergence_block(nullptr),
    velocity_solver(nullptr), inverse_diagonal(),
    velocity_space(m.get_row_space(0)), pressure_space(nullptr),
    damping_factor(0.5), gamma(1.), Poisson_solver_matrix(nullptr),
    pressure_solver(nullptr), up_star(m), bdryCorrectionMatrix_(),
    poissonMatrixBdry_(nullptr), poissonSolverBdry_(nullptr)
{
#ifdef _MPI
  if(this->spp_type != Saddle_point_preconditioner::type::lsc)
    ErrThrow("In MPI case, only least_squares_commutator is enabled so far.")
#endif
  Output::print<5>("Constructing a Saddle_point_preconditioner");
  Chrono time_measuring;
  bool pressure_correction_in_matrix = this->M->pressure_projection_enabled();
  this->M->disable_pressure_projection();

  // number of block columns and rows
  size_t n_rows = this->M->get_n_cell_rows();
  size_t n_cols = this->M->get_n_cell_columns();

  pressure_space = m.get_row_space(n_rows - 1);
  if(n_rows < 2 || n_cols != n_rows)
    ErrThrow("can not create a Saddle_point_preconditioner with this matrix");
  if(n_rows == 2 && this->spp_type == Saddle_point_preconditioner::type::bd_lsc)
    ErrThrow("boundary corrected LSC only available for (Navier-) Stokes type "
             "problems. This seems to be a Darcy type problem.\nIt is unclear "
             "how the boundary correction has to be implemented for H(div) "
             "elements");

  // velocity block K
  // take all blocks except from last row and last column
  this->velocity_block = M->get_sub_blockfematrix(0, n_rows - 2);

  this->fill_inverse_diagonal();

  /* ************************************************************************ */
  if(this->spp_type == Saddle_point_preconditioner::type::AL
     || this->spp_type == Saddle_point_preconditioner::type::mod_AL)
  {
    // get the pressure-pressure block C of the given matrix
    this->pressure_block = M->get_sub_blockfematrix(n_rows - 1, n_rows - 1);
    // assemble a pressure mass matrix (p_h, q_h)
    this->fill_pressure_mass_matrix();
    // save the inverse diagonal which builds the matrix W^{-1}
    this->fill_AL_weight_W();
    // save the augmented matrix and the augmentation for the rhs
    this->fill_augmented_matrix_and_rhs();
  }

  if(db.contains("gamma"))
  {
    this->gamma = db["gamma"];
  }

  std::string db_name = Saddle_point_preconditioner::database_name;
  if(db.get_name() == db_name || db.has_nested_database(db_name))
  {
    ErrThrow("Saddle_point_preconditioner: you provided a database with the "
             "formerly correct but now obsolete name '", db_name, "'.\nPlease "
             "provide two nested databases, one for each subproblem. See the "
             "header file Saddle_point_preconditioner.h for the exact names.");
  }
  {
    // velocity solver database
    ParameterDatabase vs_db = Solver<>::default_solver_database();
    std::string velo_db_name = Saddle_point_preconditioner::database_name_velocity_solver;
    // use the given database or one of its nested databases, depending on which
    // one has the correct name. Otherwise the default solver database is used.
    if(db.has_nested_database(velo_db_name))
    {
      //...the input database has a nested database of the required name
      vs_db.merge(db.get_nested_database(velo_db_name), false);
    }
    else
    {
      Output::warn("Saddle_point_preconditioner", "missing velocity solver "
                   "database. You should provide a nested database named ",
                   velo_db_name, ". Now a default database is used. Is this "
                   "intended?");
    }

    if(vs_db["solver_type"].is("iterative"))
    {
      Output::root_info<2>("Saddle_point_preconditioner",
                           "Note that solving systems within LSC using some "
                           "iterative routine requires a flexible solver.");
    }

#ifndef _MPI
    this->velocity_solver.reset(new Solver<BlockFEMatrix, BlockVector>(vs_db));
    this->velocity_solver->update_matrix(this->velocity_block);
#endif
#ifdef _MPI
    if(vs_db["solver_type"].is("direct"))
    {
      Output::root_info<3>("Saddle_point_preconditioner",
       "Setting up a MUMPS velocity solver.");
   /*if (this->spp_type == Saddle_point_preconditioner::type::AL)
   {
    velocity_mumps_wrapper.reset(new MumpsWrapper(this->augmented_matrix));
   }
   else */
      velocity_mumps_wrapper.reset(new MumpsWrapper(velocity_block));
    }
    else if (vs_db["solver_type"].is("iterative"))
    {
      Output::root_info<3>("Saddle_point_preconditioner",
       "Setting up an iterative velocity solver "
       "of type ", vs_db["iterative_solver_type"],".");
  /* if (this->spp_type == Saddle_point_preconditioner::type::AL)
   {
    velocity_solver.reset(new Solver<BlockMatrix, BlockVector>(vs_db));
    velocity_solver->update_matrix(this->augmented_matrix);
   }
   else
   {*/
      velocity_solver.reset(new Solver<BlockFEMatrix, BlockVector>(vs_db));
      velocity_solver->update_matrix(velocity_block);
   //}
    }
    else
      ErrThrow("What kind of solver should that be???");
#endif
  }

  // gradient block B^T
  // take last column without last block (which would be pressure-pressure)
  this->gradient_block = this->M->get_combined_submatrix(
      {0, n_cols - 1}, {n_rows - 2, n_cols - 1});
  // divergence block B
  this->divergence_block = this->M->get_combined_submatrix(
      {n_rows - 1, 0}, {n_rows - 1, n_cols - 2});

  /* ************************************************************************ */
  if(this->spp_type == Saddle_point_preconditioner::type::simple)
  {
    // scale the gradient block B^T with the approximation of the mass-matrix
    this->gradient_block->scale(&inverse_diagonal[0], true);
  }


  {
    // pressure solver database
    ParameterDatabase ps_db = Solver<>::default_solver_database();
    std::string p_db_name = Saddle_point_preconditioner::database_name_pressure_solver;
    if(db.has_nested_database(p_db_name))
    {
      //...the input database has a nested database of the required name
      ps_db.merge(db.get_nested_database(p_db_name), false);
    }
    else
    {
      Output::warn("Saddle_point_preconditioner", "missing pressure solver "
                   "database. You should provide a nested database named ",
                   p_db_name, ". Now a default database is used. Is this "
                   "intended?");
    }
    
    // construct an approximation to the Schur complement matrix
    // The argument to this function is only relevant in MPI mode. There, the
    // direct solver is mumps which accepts the matrix to be in additive storage
    // format. However this storage format can produce zeros on the diagonal on
    // a particular processor which makes some preconditioners (jacobi, sor, ..)
    // unusable. In this case we produce a matrix which is __inconsistently__
    // stored but has no nonzero entries on the diagonal. The better solution 
    // would be a consistency update for the matrix itself, but that is not 
    // implemented. So note that the given matrix is not correct on any given 
    // processor.
    this->Poisson_solver_matrix = this->compute_Poisson_solver_matrix(
      ps_db["solver_type"].is("direct"));
    
#ifndef _MPI
    this->pressure_solver.reset(new Solver<BlockFEMatrix, BlockVector>(ps_db));
    this->pressure_solver->update_matrix(*Poisson_solver_matrix);
#endif
#ifdef _MPI
    if(ps_db["solver_type"].is("direct"))
    {
      Output::root_info<3>("Saddle_point_preconditioner",
                           "Setting up a MUMPS pressure solver.");
      Poisson_solver.reset(new MumpsWrapper(*Poisson_solver_matrix));
    }
    else
    {
      Output::root_info<3>("Saddle_point_preconditioner",
                           "Setting up an iterative pressure solver "
                           "of type ",
                           ps_db["iterative_solver_type"], ".");
      pressure_solver.reset(new Solver<BlockFEMatrix, BlockVector>(ps_db));
      pressure_solver->update_matrix(*Poisson_solver_matrix);
    }
#endif
  }
  
  u_star = BlockVector(velocity_block);
  p_star = BlockVector(*this->Poisson_solver_matrix);
  u_tmp = BlockVector(u_star);
  p_tmp = BlockVector(p_star);

  /* ************************************************************************ */
  if(this->spp_type == Saddle_point_preconditioner::type::bd_lsc)
  {
    // boundary corrected LSC
    // construct correctionMatrixBdry (anew...) and fill with ones
    bdryCorrectionMatrix_
        = std::vector<double>(this->inverse_diagonal.size(), 1.);
    // set up the bdryCorrectionMatrix_
    computeBdryCorrectionMatrix(m);
    // set up the poissonMatrixBdry_
    computePoissonMatrixBdry();
    // and wrap the latter into a solver
    // poissonMatrixBdry_.PrintFull("pMB");
    poissonSolverBdry_.reset(new DirectSolver(
        *poissonMatrixBdry_, DirectSolver::DirectSolverTypes::umfpack));
  }

  if(pressure_correction_in_matrix)
    this->M->enable_pressure_projection();

  time_measuring.stop_and_print("Setting up a Saddle_point_preconditioner");
}

/* ************************************************************************** */
Saddle_point_preconditioner::Saddle_point_preconditioner(
    const BlockMatrix&, type, const ParameterDatabase&)
{
  ErrThrow("Creating a Saddle_point_preconditioner with a BlockMatrix is not "
           "possible, you need a BlockFEMatrix.");
  // otherwise the get_combined_matrix methods are possibly not giving the
  // correct behavior.
}

/* ************************************************************************** */
void Saddle_point_preconditioner::update()
{
  // we assume the velocity block has changed but not the other blocks!
  // number of block columns and rows
  unsigned int n_rows = this->M->get_n_cell_rows();
  // unsigned int n_cols = this->M->get_n_cell_columns();

  // velocity block K, delete it first because it might have changed, then
  // create a new one
  // take all blocks except from last row and last column
  this->velocity_block = M->get_sub_blockfematrix(0, n_rows - 2);

#ifndef _MPI
  this->velocity_solver->update_matrix(this->velocity_block);
#endif
#ifdef _MPI
  if(velocity_solver && velocity_mumps_wrapper)
    ErrThrow("Both velocity_solver and velocity_mumps_wrapper are "
             "initialised, that puzzles me quite a bit.");
  if(velocity_mumps_wrapper)
  {
    Output::root_info<4>(
        "Saddle_point_preconditioner: Update velocity_mumps_wrapper.");
    velocity_mumps_wrapper.reset(new MumpsWrapper(velocity_block));
  }
  else if(velocity_solver)
  {
    Output::root_info<4>(
        "Saddle_point_preconditioner: Update velocity_solver.");
    velocity_solver->update_matrix(velocity_block);
  }
  else
    ErrThrow("No velocity solver could be updated!");
#endif

  // we assume the blocks involving pressure did not change
  if(this->spp_type == Saddle_point_preconditioner::type::simple)
  { // SIMPLE
    // this is not well implemented, we need the method
    // TMatrix* TMatrix::multiply(TMatrix*, double)
    // to take the product structure, this way we could speed things up here.
    // Instead all members are deleted and recreated

    // descale the gradient_block:
    unsigned int n_diagonal_entries = inverse_diagonal.size();
    for(unsigned int d = 0; d < n_diagonal_entries; ++d)
      this->inverse_diagonal[d] = 1.0 / this->inverse_diagonal[d];
    this->gradient_block->scale(&inverse_diagonal[0], true);

    // recompute the inverse_diagonal (of velocity_block)
    this->fill_inverse_diagonal();

    // scale the gradient block B^T with the inverse_diagonal
    this->gradient_block->scale(&inverse_diagonal[0], true);

    // recompute the Poisson_solver_matrix and then create new Poisson_solver
    this->Poisson_solver_matrix = this->compute_Poisson_solver_matrix();


#ifndef _MPI
    this->pressure_solver->update_matrix(*Poisson_solver_matrix);
#endif
#ifdef _MPI
    if(this->Poisson_solver)
    {
      Poisson_solver.reset(new MumpsWrapper(*Poisson_solver_matrix));
    }
    else
    {
      this->pressure_solver->update_matrix(*Poisson_solver_matrix);
    }
#endif
  }
  else if(this->spp_type == Saddle_point_preconditioner::type::lsc
          || this->spp_type == Saddle_point_preconditioner::type::bd_lsc)
  {
    // nothing more needs to be done here

    // members which do not change and therefore do not need to be recomputed:
    // - gradient and divergence block
    // - inverse_diagonal
    // - Poisson_solver_matrix
    // - pressure_solver/Poisson_solver
    // - velocity_space, pressure_space
  }
}

/* ************************************************************************** */
void Saddle_point_preconditioner::solve_velocity(const BlockVector& rhs,
                                                 BlockVector& sol) const
{
  Output::print<5>("Saddle_point_preconditioner, solve_velocity");
  unsigned int verbosity = Output::getVerbosity();
  // Output::suppressAll();
  Output::setVerbosity(1);
#ifndef _MPI
  /// velocity_solver->get_db().info(true); //NEW
  if((this->spp_type == Saddle_point_preconditioner::type::AL)
     || (this->spp_type == Saddle_point_preconditioner::type::mod_AL))
  {
    velocity_solver->solve_augmented(rhs, sol);
  }
  else
  {
    velocity_solver->solve(rhs, sol);
  }

#endif
#ifdef _MPI
  // decide whether velocity_solver or velocity_mumps_wrapper must be used
  if(velocity_solver && velocity_mumps_wrapper)
    ErrThrow("Both velocity_solver and velocity_mumps_wrapper are "
             "initialised, that puzzles me quite a bit.");
  if(velocity_solver)
  {
    if((this->spp_type == Saddle_point_preconditioner::type::AL)
       || (this->spp_type == Saddle_point_preconditioner::type::mod_AL))
    {
      velocity_solver->solve_augmented(rhs, sol);
    }
    else
    {
      velocity_solver->solve(rhs, sol);
    }
  }
  else if(velocity_mumps_wrapper)
  {
    if((this->spp_type == Saddle_point_preconditioner::type::AL)
       || (this->spp_type == Saddle_point_preconditioner::type::mod_AL))
    {
      ErrThrow("no augmented Lagrangian possible with a direct velocity solver "
               "yet.");
      // velocity_mumps_wrapper->solve_augmented(rhs, sol);
    }
    else
    {
      velocity_mumps_wrapper->solve(rhs, sol);
    }
  }
  else
    ErrThrow("No velocity solver could be found!");
#endif
  Output::setVerbosity(verbosity); // reset verbosity for further output
}

/* ************************************************************************** */
void Saddle_point_preconditioner::apply(const BlockVector& z,
                                        BlockVector& r) const
{
  Output::print<5>("Saddle_point_preconditioner::apply");
  if(r.n_blocks() == 0)
  {
    // only the standard constructor has been called for r so far
    r.copy_structure(z); // copy the structure of z, all entries are zero
  }
  else
  {
    r.reset(); // set all entries to zero
  }
  up_star = 0.; // ToDo: Check if this can be deleted

  switch(this->spp_type)
  {
    case Saddle_point_preconditioner::type::simple:
    {
      // Output::print<5>("SIMPLE Saddle_point_preconditioner::solve");
      // up_star includes du* and dp*
      // ----------------------------------------------------------------------
      // solve A du* = r_u
      u_tmp = z.get_entries();
      solve_velocity(u_tmp, u_star);

      // ----------------------------------------------------------------------
      // solve S dp* = r_p - B du*
      // use BlockVector r to store the right hand side for the system
      // involving the Schur approximation
      unsigned int n_blocks = z.n_blocks();
      p_tmp = z.block(n_blocks - 1);
      // do r_p += -B * du*

      this->divergence_block->multiply(u_star.get_entries(),
                                       p_tmp.get_entries(), -1.);
#ifdef _MPI
      if(this->Poisson_solver)
        this->Poisson_solver->solve(p_tmp, p_star);
      else
#endif // MPI
      {
        this->pressure_solver->solve(p_tmp, p_star);
      }

      // ----------------------------------------------------------------------
      // dp = dp*
      r.copy(p_star.get_entries(), n_blocks - 1);
      // du = du* - D^-1 B^T dp*
      // there are zeros in the u-block of r currently
      // store the result of -B^T dp* in u-block of r
      gradient_block->multiply(p_star.get_entries(), r.get_entries(), -1.);
      // scale with D^-1, loop over all velocity entries
      for(unsigned int i = 0, n_v = gradient_block->get_n_rows(); i < n_v; ++i)
      {
        r[i] *= this->inverse_diagonal[i];
      }
      // add du*
      for(unsigned int i = 0; i < n_blocks - 1; ++i)
        r.add(u_star.block(i), i);

      // ----------------------------------------------------------------------
      // update r = z + omega (dp, du)
      r *= this->damping_factor;
      r += z;
      break;
    }
    case Saddle_point_preconditioner::type::lsc:
    case Saddle_point_preconditioner::type::bd_lsc:
    {
      // a short name to tell if the correction at the boundary should be done
      bool correct_boundary
          = this->spp_type == Saddle_point_preconditioner::type::bd_lsc;
      // The cases lsc and bd_lsc only differ in Step 1 and substep 2.2!
      unsigned int n_blocks = z.n_blocks();

      // Step 1: Poisson solver: solve S_p p_star = p_tmp = z_p, where
      // S_p = B Q^(-1) B^T
      p_tmp = z.block(n_blocks - 1);

      // MPI: it is not necessary to update p_tmp,
      // because rhs 'z' enters in consistency lvl 3

      if(correct_boundary)
        this->poissonSolverBdry_->solve(p_tmp, p_star);
      else
      {
#ifdef _MPI
        if(this->Poisson_solver)
          this->Poisson_solver->solve(p_tmp, p_star);
        else
#endif // MPI
        {
          this->pressure_solver->solve(p_tmp, p_star);
        }
      }

        // Step 2. Update p_tmp = -B Q^(-1) K Q^(-1) B^T p_star
#ifdef _MPI
      const TParFECommunicator3D& u_comm = *M->get_communicators()[0];
      const TParFECommunicator3D& p_comm = *M->get_communicators()[3];
      // update p_star to lvl3, for matrix-vector product.
      p_comm.consistency_update(p_star.get_entries(), 3);
#endif

      // Substep 2.1. Compute B^T p_star and store it in u_tmp
      u_tmp = 0.;
      gradient_block->multiply(p_star.get_entries(), u_tmp.get_entries(), -1.0);

      // Substep 2.2. Compute Q^(-1) B^T p_star and store it in u_tmp
      if(correct_boundary)
      {
        for(unsigned int i = 0, n_v = gradient_block->get_n_rows(); i < n_v; ++i)
        {
          u_tmp[i] *= this->bdryCorrectionMatrix_[i];
        }
      }
      else
      {
        for(unsigned int i = 0, n_v = gradient_block->get_n_rows(); i < n_v; ++i)
        {
          u_tmp[i] *= this->inverse_diagonal[i];
        }
      }

#ifdef _MPI
      // update u_tmp to lvl3, for matrix-vector product.
      u_comm.consistency_update(u_tmp.block(0), 3);
      u_comm.consistency_update(u_tmp.block(1), 3);
      u_comm.consistency_update(u_tmp.block(2), 3);
#endif
      // Substep 2.3. Compute  K Q^(-1) B^T p_star and store it in u_star
      velocity_block.apply(u_tmp, u_star);

      // Substep 2.4. Compute Q^(-1) K Q^(-1) B^T p_star and store it in u_star
      for(unsigned int i = 0, n_v = gradient_block->get_n_rows(); i < n_v; ++i)
      {
        u_star[i] *= this->inverse_diagonal[i];
      }

#ifdef _MPI
      // MPI: update u_star to lvl 3, so that the matrix-vector
      //     product below will result in a lvl 0 consistent u_star.
      u_comm.consistency_update(u_star.block(0), 3);
      u_comm.consistency_update(u_star.block(1), 3);
      u_comm.consistency_update(u_star.block(2), 3);
#endif
      // Subset 2.5. Compute B Q^(-1) K Q^(-1) B^T p_star and store it in p_tmp
      p_tmp.reset();
      divergence_block->multiply(u_star.get_entries(), p_tmp.get_entries(), 1.);

      // MPI: no update of p_tmp, it is the RHS in the call to solve
      //     below, thus consistency lvl 0 is enough.

      // Step 3: 2. solver solve S_p p_star = p_tmp and store it in p_star
#ifdef _MPI
      if(this->Poisson_solver)
        this->Poisson_solver->solve(p_tmp, p_star);
      else
#endif // MPI
      {
        this->pressure_solver->solve(p_tmp, p_star);
      }

#ifdef _MPI
      // MPI: update p_star to lvl 3, so that the matrix-vector
      //     product below will result in a lvl 0 consistent u_star.
      p_comm.consistency_update(p_star.get_entries(), 3);
#endif

      // Step 4. Update u_star = z_u - B^T p_star
      u_star = z.get_entries();
      gradient_block->multiply(p_star.get_entries(), u_star.get_entries(), -1.);

      // MPI: No update of u_star necessary, it is the RHS in the
      //     solve_velocity call below, consistency 0 is enough.

      // Step 5. Solve K u_tmp = u_star
      solve_velocity(u_star, u_tmp);

      // MPI: No update of u_tmp necessasry, solution 'r'
      //     must only leave this method in consistency 0.

      r.reset();
      // copy u_tmp and p_star back to r
      for(unsigned int i = 0; i < n_blocks - 1; ++i)
        r.add(u_tmp.block(i), i);
      r.copy(p_star.block(0), n_blocks - 1);

      if(this->damping_factor != 1.0)
      {
        r.scale(this->damping_factor);
        r.add_scaled(z, 1 - this->damping_factor);
      }

      // IntoL20FEFunction(r.block(n_blocks-1), r.length(n_blocks-1),
      //                  pressure_space,
      //                  TDatabase::ParamDB->VELOCITY_SPACE,
      //                  TDatabase::ParamDB->PRESSURE_SPACE);
      break;
    }
    case Saddle_point_preconditioner::type::AL:
    case Saddle_point_preconditioner::type::mod_AL:
    {
      /*** The purpose of this function is to solve P^{-1}*z = r via P*r = z for
       * r. ***/
      /*** Here, z = (z_u, z_p) is given. ***/
      /*** P:=  (A_gamma          B^T    ) ***/
      /***      (0           1/gamma W ) ***/

      // Step 1: 'Poisson solver': solve S_p * p_star = p_tmp = z_p for p_star,
      // where S_p^{-1} := - \nu * M_p^{-1} - gamma * W^{-1} with M_p being the
      // pressure mass matrix or its diagonal, W is any SPD matrix, e.g., W =
      // diag(A)^{-1} or even M_p or its diagonal


      unsigned int n_blocks = z.n_blocks();

      p_tmp = z.block(n_blocks - 1);
      p_tmp.scale(this->gamma); // p_tmp *= this->gamma;
      // W * p_star = p_temp, W:= diag[Mp]
#ifdef _MPI
      if(this->Poisson_solver)
        this->Poisson_solver->solve(p_tmp, p_star);
      else
#endif // MPI
      {
        this->pressure_solver->solve(p_tmp, p_star);
      }


      // Step 2: solve A_gamma * u_star = z_u - B^T * p_star for u_star
      // Substep 2.1 Update u_star = z_u - B^T * p_star
      u_star = z.get_entries(); // u_star = z_u //REWRITE for AL: A has to be
                                // augmented
      gradient_block->multiply(p_star.get_entries(), u_star.get_entries(),
                               -1.); // z_u - B^T * p_star

      // Substep 2.2 Solve A_gamma * u_tmp = u_star
      solve_velocity(u_star, u_tmp);

      r.reset();
      // copy u_tmp and p_star back to r
      for(unsigned int i = 0; i < n_blocks - 1; i++)
        r.add(u_tmp.block(i), i);
      r.copy(p_star.block(0), n_blocks - 1);

      if(this->damping_factor != 1.0)
      {
        r.scale(this->damping_factor);
        r.add_scaled(z, 1 - this->damping_factor);
      }

      break;
    }
    default:
      ErrThrow("unknown saddle point preconditioner type");
      break;
  }
}

/* ************************************************************************** */

void Saddle_point_preconditioner::apply(int, int, const BlockVector& z,
                                        BlockVector& r) const
{
  this->apply(z, r);
}

/* ************************************************************************** */
/* LSC === */
std::shared_ptr<BlockFEMatrix>
Saddle_point_preconditioner::compute_Poisson_solver_matrix(
  bool additive_storage) const
{
  std::shared_ptr<TMatrix> ret(nullptr);

  // get the matrix, put it into a shared_ptr, essentially this is the matrix
  // which should be returned
  switch(this->spp_type)
  {
    case Saddle_point_preconditioner::type::simple:
      ret.reset(
          this->divergence_block->multiply(this->gradient_block.get(), 1.));
      break;
    case Saddle_point_preconditioner::type::lsc:    // original LSC
    case Saddle_point_preconditioner::type::bd_lsc: // bdry corrected LSC
#ifndef _MPI

      ret.reset(divergence_block->multiply_with_transpose_from_right(
          inverse_diagonal));
      // avoid compiler warning
      (void)additive_storage;
#endif
#ifdef _MPI
      {
        const TParFECommunicator3D* u_comm = M->get_communicators()[0];
        const TParFECommunicator3D* p_comm = M->get_communicators()[3];
        std::vector<const TParFECommunicator3D*> test_comms = {p_comm};
        std::vector<const TParFECommunicator3D*> ansatz_comms
            = {u_comm, u_comm, u_comm};

        ret.reset(divergence_block->multiply_with_transpose_from_right(
            inverse_diagonal, test_comms, ansatz_comms, additive_storage));
      }
#endif
      break;
    case Saddle_point_preconditioner::type::AL:
    case Saddle_point_preconditioner::type::mod_AL:

      ret = std::make_shared<TMatrix>(
          this->diagonal_of_W,
          std::make_shared<TStructure>(
              pressure_mass.get_combined_matrix()->GetStructure()));
      //// last: ret = std::make_shared<TMatrix>(this->diagonal_of_W,
      ///Structure);
      /// OLD 11.06.18 ret = pressure_mass.get_combined_matrix();

      break;
    default:
      ErrThrow("unknown preconditioner for saddle point problems ");
      break;
  }
  // put the shared_ptr into a vector
  auto fe_matrix = std::make_shared<FEMatrix>(pressure_space, *ret);
  std::vector<std::shared_ptr<FEMatrix>> vec(1, fe_matrix);
  // create a BlockMatrix and return it
  return std::make_shared<BlockFEMatrix>(1, 1, vec);
}

/* ************************************************************************** */
// local assembling routine to assemble a pressure mass matrix
// This needs to go into some assembling class!
void local_assembling_pressure_mass_matrix(double Mult, const double*,
                                           const double*, double,
                                           const double** OrigValues,
                                           const int* N_BaseFuncts,
                                           double*** LocMatrices, double**)
{
  // assemble (p,q) at a specific quadrature point in a specific cell
  double** Mp = LocMatrices[0];
  const double* p_values = OrigValues[0]; // the values of p (and q)

  const int N_P = N_BaseFuncts[0];
  for(int i = 0; i < N_P; i++)
  {
    double test00 = p_values[i];

    for(int j = 0; j < N_P; j++)
    {
      double ansatz00 = p_values[j];
      Mp[i][j] += Mult * (ansatz00 * test00);
    } // endfor j
  }   // endfor i
}


/* === LSC */
/* ************************************************************************** */
// local assembling routine to assemble a mass velocity matrix
// This needs to go into some assembling class!
bool has_vector_valued_basis_functions;
void local_assembling_velocity_mass(double Mult, const double*, const double*,
                                    double, const double** OrigValues,
                                    const int* N_BaseFuncts,
                                    double*** LocMatrices, double**)
{
  // assemble (u,v) at a specific quadrature point in a specific cell
  double** MatrixM = LocMatrices[0];
  const double* u_values = OrigValues[0]; // the values of u (and v)

  const int N_U = N_BaseFuncts[0];
  for(int i = 0; i < N_U; i++)
  {
    double* MatrixM_row = MatrixM[i];
    double test00 = u_values[i];

    for(int j = 0; j < N_U; j++)
    {
      double ansatz00 = u_values[j];
      MatrixM_row[j] += Mult * (ansatz00 * test00);
    } // endfor j
  }   // endfor i
  if(has_vector_valued_basis_functions)
  {
    for(int i = 0; i < N_U; i++)
    {
      double* MatrixM_row = MatrixM[i];
      double test00_y = u_values[i + N_U];

      for(int j = 0; j < N_U; j++)
      {
        double ansatz00_y = u_values[j + N_U];
        MatrixM_row[j] += Mult * (ansatz00_y * test00_y);
      } // endfor j
    }   // endfor i
#ifdef __3D__
    for(int i = 0; i < N_U; i++)
    {
      double* MatrixM_row = MatrixM[i];
      double test00_z = u_values[i + 2 * N_U];

      for(int j = 0; j < N_U; j++)
      {
        double ansatz00_z = u_values[j + 2 * N_U];
        MatrixM_row[j] += Mult * (ansatz00_z * test00_z);
      } // endfor j
    }   // endfor i
#endif  // 3D
  }
}
/* ****************************************************** */

void Saddle_point_preconditioner::fill_pressure_mass_matrix()
{
  Output::print<1>(
      "Started to assemble pressure mass matrix for Augm. Lagr. prec.");
  // mass-matrix Q and its approximation
  if((this->spp_type == Saddle_point_preconditioner::type::AL)
     || (this->spp_type == Saddle_point_preconditioner::type::mod_AL))
  {
    // first: assemble a pressure mass matrix
#ifdef __2D__
    typedef MultiIndex2D MultiIndex;
    MultiIndex p = MultiIndex2D::D00; // value, no derivatives
    typedef CoeffFct2D CoeffFct;
    typedef TFEFunction2D FEFunction;
    typedef LocalAssembling2D LocalAssembling;
    typedef TSquareMatrix2D SqMat;
    typedef TMatrix2D RectMat;
    typedef TFESpace2D FESpace;
    typedef BoundCondFunct2D BoundCondFunct;
    typedef BoundValueFunct2D BoundValueFunct;
#else
    typedef MultiIndex3D MultiIndex;
    MultiIndex p = MultiIndex3D::D000; // value, no derivatives
    typedef CoeffFct3D CoeffFct;
    typedef TFEFunction3D FEFunction;
    typedef LocalAssembling3D LocalAssembling;
    typedef TSquareMatrix3D SqMat;
    typedef TMatrix3D RectMat;
    typedef TFESpace3D FESpace;
    typedef BoundCondFunct3D BoundCondFunct;
    typedef BoundValueFunct3D BoundValueFunct;
#endif

    // create an appropriate LocalAssembling2D object:
    // We will assemble a pressure block and then create a BlockMatrix
    int n_terms = 1;                           // only 1 term (p,q)
    std::vector<MultiIndex> derivatives(1, p); // that one term is the value
    std::vector<int> fe_space_numbers(1, 0);   // only 1 space with index 1
    std::vector<int> row_space(1, 0);          // 1 matrix
    std::vector<int> column_space(1, 0);       // 1 matrix
    std::vector<int> rhs_space(1, 0);          // not needed
    CoeffFct coeff;                            // no coefficients
    AssembleFctParam local_assembling_function
        = local_assembling_pressure_mass_matrix;
    ManipulateFct* manipulate = nullptr;        // not needed
    int n_matrices = 1;                         // assemble only one matrix
    int n_rhs = 0;                              // no right hand side
    int n_parameter = 0;                        // not needed
    std::vector<ParamFct*> parameter_functions; // no parameter functions
    std::vector<int> begin_parameter;           // not needed
    int n_parameters = 0;                       // not needed
    std::vector<const FEFunction*> fe_functions;
    int n_fe_values = 0;                      // no other fe values are needed
    std::vector<int> fe_value_function_index; // not needed
    std::vector<MultiIndex> fe_value_multi_index; // not needed

    LocalAssembling la(n_terms, derivatives, fe_space_numbers, row_space,
                       column_space, rhs_space, coeff,
                       {local_assembling_function}, manipulate, n_matrices,
                       n_rhs, n_parameter, parameter_functions, begin_parameter,
                       n_parameters, fe_functions, n_fe_values,
                       fe_value_function_index, fe_value_multi_index);

    // prepare a call to Assemble2D
    int n_fe_spaces = 1;
    SqMat* sq_matrices[1];

    // FESpace* neumann_velocity_space =
    //  this->velocity_space->copy_with_all_Neumann_boundary();
    // const FESpace* v_space = neumann_velocity_space;
    auto q_space = this->pressure_space.get();

    SqMat one_block_of_mass_matrix(this->pressure_space);

    sq_matrices[0] = &one_block_of_mass_matrix;
    int n_rect_mat = 0; // only square matrices
    RectMat** rect_matrices = nullptr;
    double** rhs = nullptr; // right hand sides
    const FESpace** fe_spaces_rhs = nullptr;
    // which boundary conditions are correct here? We could as well use the ones
    // from the velocity_space. We use three even in 2D, where two would be ok.
    BoundCondFunct* boundary_conditions[3]
        = {BoundConditionNoBoundCondition, BoundConditionNoBoundCondition,
           BoundConditionNoBoundCondition};
    BoundValueFunct* non_const_bound_values[3]
        = {BoundaryValueHomogenous, BoundaryValueHomogenous,
           BoundaryValueHomogenous};


#ifdef __2D__
    Assemble2D(n_fe_spaces, &q_space, n_matrices, sq_matrices, n_rect_mat,
               rect_matrices, n_rhs, rhs, fe_spaces_rhs, boundary_conditions,
               non_const_bound_values, la);

    BlockFEMatrix pressure_mass_matrix({this->pressure_space});
    pressure_mass_matrix.replace_blocks(one_block_of_mass_matrix, {{0, 0}},
                                        {false});
#else
    Assemble3D(n_fe_spaces, &q_space, n_matrices, sq_matrices, n_rect_mat,
               rect_matrices, n_rhs, rhs, fe_spaces_rhs, boundary_conditions,
               non_const_bound_values, la);

    BlockFEMatrix pressure_mass_matrix({this->pressure_space});
    pressure_mass_matrix.replace_blocks(one_block_of_mass_matrix, {{0, 0}},
                                        {false});
#endif

    this->pressure_mass = pressure_mass_matrix;
  }
  Output::print<1>(
      "Finished to assemble pressure mass matrix for Augm. Lagr. prec.");
}


/* **************************************************************** */
void Saddle_point_preconditioner::fill_inverse_diagonal()
{
  // number of entries on diagonal in velocity_block
  size_t n_diagonal_entries = this->velocity_block.get_n_total_rows();

  this->inverse_diagonal.resize(n_diagonal_entries, 0.);

  // mass-matrix Q and its approximation
  if(this->spp_type == Saddle_point_preconditioner::type::simple)
  {
    // SIMPLE
    for(unsigned int d = 0; d < n_diagonal_entries; ++d)
    {
      this->inverse_diagonal[d] = 1.0 / this->velocity_block.get(d, d);
    }
  }
  else if((this->spp_type == Saddle_point_preconditioner::type::lsc)
          || (this->spp_type == Saddle_point_preconditioner::type::bd_lsc))
  {
    // first: assemble a velocity mass matrix

#ifdef __2D__
    typedef MultiIndex2D MultiIndex;
    MultiIndex v = MultiIndex2D::D00; // value, no derivatives
    typedef CoeffFct2D CoeffFct;
    typedef TFEFunction2D FEFunction;
    typedef LocalAssembling2D LocalAssembling;
    typedef TSquareMatrix2D SqMat;
    typedef TMatrix2D RectMat;
    typedef TFESpace2D FESpace;
    typedef BoundCondFunct2D BoundCondFunct;
    typedef BoundValueFunct2D BoundValueFunct;
#else
    typedef MultiIndex3D MultiIndex;
    MultiIndex v = MultiIndex3D::D000; // value, no derivatives
    typedef CoeffFct3D CoeffFct;
    typedef TFEFunction3D FEFunction;
    typedef LocalAssembling3D LocalAssembling;
    typedef TSquareMatrix3D SqMat;
    typedef TMatrix3D RectMat;
    typedef TFESpace3D FESpace;
    typedef BoundCondFunct3D BoundCondFunct;
    typedef BoundValueFunct3D BoundValueFunct;
#endif

    // create an appropriate LocalAssembling2D object:
    // We will assemble only one velocity block and then create a BlockMatrix
    // where this one block appears twice (three times in 3D)
    int n_terms = 1;                           // only 1 term (u,v)
    std::vector<MultiIndex> derivatives(1, v); // that one term is the value
    std::vector<int> fe_space_numbers(1, 0);   // only 1 space with index 0
    std::vector<int> row_space(1, 0);          // 1 matrix
    std::vector<int> column_space(1, 0);       // 1 matrix
    std::vector<int> rhs_space(1, 0);          // not needed
    CoeffFct coeff;                            // no coefficients
    AssembleFctParam local_assembling_function = local_assembling_velocity_mass;
    ManipulateFct* manipulate = nullptr;        // not needed
    int n_matrices = 1;                         // assemble only one matrix
    int n_rhs = 0;                              // no right hand side
    int n_parameter = 0;                        // not needed
    std::vector<ParamFct*> parameter_functions; // no parameter functions
    std::vector<int> begin_parameter;           // not needed
    int n_parameters = 0;                       // not needed
    std::vector<const FEFunction*> fe_functions;
    int n_fe_values = 0;                      // no other fe values are needed
    std::vector<int> fe_value_function_index; // not needed
    std::vector<MultiIndex> fe_value_multi_index; // not needed
    LocalAssembling la(n_terms, derivatives, fe_space_numbers, row_space,
                       column_space, rhs_space, coeff,
                       {local_assembling_function}, manipulate, n_matrices,
                       n_rhs, n_parameter, parameter_functions, begin_parameter,
                       n_parameters, fe_functions, n_fe_values,
                       fe_value_function_index, fe_value_multi_index);

    // prepare a call to Assemble2D
    int n_fe_spaces = 1;
    SqMat* sq_matrices[1];

    const FESpace* v_space = this->velocity_space.get();

    SqMat one_block_of_mass_matrix(this->velocity_space);

    sq_matrices[0] = &one_block_of_mass_matrix;
    int n_rect_mat = 0; // only square matrices
    RectMat** rect_matrices = nullptr;
    double** rhs = nullptr; // right hand sides
    const FESpace** fe_spaces_rhs = nullptr;
    // which boundary conditions are correct here? We could as well use the ones
    // from the velocity_space. We use three even in 2D, where two would be ok.
    BoundCondFunct* boundary_conditions[3]
        = {BoundConditionNoBoundCondition, BoundConditionNoBoundCondition,
           BoundConditionNoBoundCondition};
    BoundValueFunct* non_const_bound_values[3]
        = {BoundaryValueHomogenous, BoundaryValueHomogenous,
           BoundaryValueHomogenous};

    if(this->velocity_space->get_fe(0).GetBaseFunct()->GetBaseVectDim() != 1)
      has_vector_valued_basis_functions = true;
    else
      has_vector_valued_basis_functions = false;
#ifdef __2D__
    Assemble2D(n_fe_spaces, &v_space, n_matrices, sq_matrices, n_rect_mat,
               rect_matrices, n_rhs, rhs, fe_spaces_rhs, boundary_conditions,
               non_const_bound_values, la);
    BlockFEMatrix mass_matrix({this->velocity_space, this->velocity_space});
    mass_matrix.replace_blocks(one_block_of_mass_matrix, {{0, 0}, {1, 1}},
                               {false, false});
#else
    Assemble3D(n_fe_spaces, &v_space, n_matrices, sq_matrices, n_rect_mat,
               rect_matrices, n_rhs, rhs, fe_spaces_rhs, boundary_conditions,
               non_const_bound_values, la);
    BlockFEMatrix mass_matrix(
        {this->velocity_space, this->velocity_space, this->velocity_space});
    mass_matrix.replace_blocks(one_block_of_mass_matrix,
                               {{0, 0}, {1, 1}, {2, 2}}, {false, false, false});
#endif

    // number of entries on diagonal in mass matrix
    for(unsigned int d = 0; d < n_diagonal_entries; ++d)
    {
      this->inverse_diagonal[d] = 1.0 / mass_matrix.get(d, d);
    }
#ifdef _MPI
    // update the inverse diagonal to consistency level 3 (full consistent
    // storage).
    const TParFECommunicator3D& velo_comm = *M->get_communicators()[0];
    velo_comm.consistency_update(&inverse_diagonal[0], 3);
    velo_comm.consistency_update(&inverse_diagonal[velo_comm.GetNDof()], 3);
    velo_comm.consistency_update(&inverse_diagonal[2 * velo_comm.GetNDof()], 3);
#endif
  }
}


/* ************************************************************************** */
/* Extra methods for boundary corrected LSC */

/** Sets up bdryCorrectionMatrix_. */
#ifdef __2D__
void Saddle_point_preconditioner::computeBdryCorrectionMatrix(
    const BlockFEMatrix& m)
{
  // the problem parameter epsilon - chosen 0.1 as proposed by the authors
  double epsilon = 0.1;

  // just a simple check
  if(this->velocity_space != m.get_row_space(0))
    ErrThrow("bd_lsc preconditioner: matrix has wrong fe space");

  // Hold a reference to the TCollection underlying the problem
  const TCollection& collection = *this->velocity_space->GetCollection();

  // loop over cells in the collection
  for(int iCells = 0; iCells < collection.GetN_Cells(); ++iCells)
  {
    // hold a reference to the current cell
    const TBaseCell& cell = *collection.GetCell(iCells);
    // loop over cell's joints
    for(int iJoints = 0; iJoints < cell.GetN_Joints(); ++iJoints)
    {
      // find out if this cell has a boundary joint
      if(!cell.GetJoint(iJoints)->InnerJoint())
      {
        // this is a joint on the boundary, so a TBoundEdge (in 2D)
        // but is it on a Dirichlet boundary part?
        const TBoundEdge& edge
            = *dynamic_cast<const TBoundEdge*>(cell.GetJoint(iJoints));
        // get ID of the boundary component -- looks like we can work with this
        // component!
        int componentID = edge.GetBoundComp()->GetID();
        BoundCond componentType;
        // the parameter on the boundary component which refers to the center
        // of 'edge'
        double t_c = (edge.GetStartParameter() + edge.GetEndParameter()) / 2.;
        // the 0 for velo space, componentID for global ID of the boundary
        // component,
        this->velocity_space->get_boundary_condition()(componentID, t_c,
                                                       componentType);
        if(componentType == DIRICHLET)
        {
          // Output::print("Found a cell with a Dirchlet boundary edge.");
          // we found a cell with an edge on the dirichlet bondary. time to
          // start working:

          // fetch and store coordinates of beginning and ending of the edge
          //(ASSUMING THE EDGE IS A LINE (class TBdLine))
          double startX, startY, endX, endY;
          edge.GetBoundComp()->GetXYofT(edge.GetStartParameter(), startX,
                                        startY);
          edge.GetBoundComp()->GetXYofT(edge.GetEndParameter(), endX, endY);
          // calculate unit normal on the edge (orientation is of no interest
          // here)
          double normalX = endY - startY;
          double normalY = startX - endX;
          double norm = std::sqrt(normalX * normalX + normalY * normalY);
          normalX /= norm;
          normalY /= norm;

          // those are the values to be written into the matrix
          double horizontalDofsCorrectionValue
              = std::max(std::abs(normalX), epsilon);
          double verticalDofsCorrectionValue = std::max(std::abs(normalY), epsilon);

          // now write the relevant matrix entries
          // loop over velocity dofs belonging to cell
          for(int j = 0, n_local_dof = velocity_space->get_n_local_dof(iCells);
              j < n_local_dof; ++j)
          {
            int iVeloDof = velocity_space->get_global_dof(iCells, j);

            // here we rely on the correct ordering of the velo dofs!
            // this is a horizontal (x-direction) velo dof
            bdryCorrectionMatrix_[iVeloDof] = horizontalDofsCorrectionValue;
            // Output::print("Horizontal velo dof ", iVeloDof, " in Cell ",
            //               iCells, " put correction to ",
            //               horizontalDofsCorrectionValue);
            // this is a vertical (y-direction) velo dof
            bdryCorrectionMatrix_.at(velocity_space->get_n_dof()
                                     + iVeloDof)
                = verticalDofsCorrectionValue;
          } // end loop over velocity dofs
        }   // end if dirichlet boundary
      }     // end if boundary joint
    }       // end loop over joints
  }         // end loop over cells


  // to store the correct matrix "H^{-1}= D*D_Q^{-1}" we have to scale with the
  // diagonal mass inverse
  std::transform(bdryCorrectionMatrix_.begin(), bdryCorrectionMatrix_.end(),
                 inverse_diagonal.begin(), bdryCorrectionMatrix_.begin(),
                 std::multiplies<double>());
}

#endif // __2D__
#ifdef __3D__
void Saddle_point_preconditioner::computeBdryCorrectionMatrix(
    const BlockFEMatrix& m)
{
  // the problem parameter epsilon - chosen 0.1 as proposed by the authors
  double epsilon = 0.1;

  // just a simple check
  if(this->velocity_space.get() != m.get_row_space(0).get())
    ErrThrow("bd_lsc preconditioner: matrix has wrong fe space");

  // Hold a reference to the TCollection underlying the problem
  const TCollection& collection = *this->velocity_space->GetCollection();

  // loop over cells in the collection
  for(int iCells = 0; iCells < collection.GetN_Cells(); ++iCells)
  {
    // hold a reference to the current cell
    TBaseCell& cell = *collection.GetCell(iCells);
    // loop over cell's joints
    for(int iJoints = 0; iJoints < cell.GetN_Joints(); ++iJoints)
    {
      // find out if this cell has a boundary joint
      if(!cell.GetJoint(iJoints)->InnerJoint())
      {
        // this joint is on the boundary, check if it is on a Dirichlet boundary
        BoundCond componentType;
        const int *face_vertex, *face_vertex_length;
        int m_l; // max_length
        cell.GetShapeDesc()->GetFaceVertex(face_vertex, face_vertex_length,
                                           m_l);
        // compute center of face in order to then evaluate the boundary
        // condition there
        double x = 0, y = 0, z = 0;
        auto boundface              = (TBoundFace*)cell.GetJoint(iJoints);
        const TBoundComp* BoundComp = boundface->GetBoundComp();
        int comp                    = BoundComp->get_physical_id();
        for(int v = 0; v < face_vertex_length[iJoints]; ++v)
        {
          TVertex* vertex = cell.GetVertex(face_vertex[iJoints * m_l + v]);
          x += vertex->GetX();
          y += vertex->GetY();
          z += vertex->GetZ();
        }
        x /= face_vertex_length[iJoints];
        y /= face_vertex_length[iJoints];
        z /= face_vertex_length[iJoints];
        // the 0 for velo space, 1 would be pressure
        this->velocity_space->get_boundary_condition()(comp, x, y, z,
                                                       componentType);
        if(componentType == DIRICHLET)
        {
          // Output::print("Found a cell with a Dirchlet boundary edge.");
          // we found a cell with an edge on  dirichlet bondary. time to start
          // working:

          // find the normal of this face
          // Assuming this face is a PLANE or WALL (class TBdPlane or TBdWall)
          double normalX, normalY, normalZ;
          {
            TBoundFace& face
                = *dynamic_cast<TBoundFace*>(cell.GetJoint(iJoints));
            BoundTypes bt = face.GetBoundComp()->GetType();
            if(bt == Cylinder || bt == Sphere)
              ErrThrow("getting normal on cylinder or sphere possibly not "
                       "working");

            if(face_vertex_length[iJoints] < 3)
              ErrThrow("a joint in 3D has less than three vertices???");
            double ux, uy, uz, vx, vy, vz;
            // helping doubles to evaluate coordinates for some vertices
            double X = 0, Y = 0, Z = 0;
            cell.GetVertex(face_vertex[iJoints * m_l])->GetCoords(X, Y, Z);
            ux = vx = -X;
            uy = vy = -Y;
            uz = vz = -Z;
            cell.GetVertex(face_vertex[iJoints * m_l + 1])->GetCoords(X, Y, Z);
            ux += X;
            uy += Y;
            uz += Z;
            cell.GetVertex(face_vertex[iJoints * m_l + 2])->GetCoords(X, Y, Z);
            vx += X;
            vy += Y;
            vz += Z;
            normalX = uy * vz - uz * vy;
            normalY = uz * vx - ux * vz;
            normalZ = ux * vy - uy * vx;
            double norm = std::sqrt(normalX * normalX + normalY * normalY
                               + normalZ * normalZ);
            normalX /= norm;
            normalY /= norm;
            normalZ /= norm;
          }

          // those are the values to be written into the matrix
          double x_DofsCorrectionValue = std::max(std::abs(normalX), epsilon);
          double y_DofsCorrectionValue = std::max(std::abs(normalY), epsilon);
          double z_DofsCorrectionValue = std::max(std::abs(normalZ), epsilon);

          // now write the relevant matrix entries
          // loop over velocity dofs belonging to cell
          for(int j = 0, n_local_dof = velocity_space->get_n_local_dof(iCells);
              j < n_local_dof; ++j)
          {
            int iVeloDof = velocity_space->get_global_dof(iCells, j);

            // here we rely on the correct ordering of the velo dofs!
            // this is a horizontal (x-direction) velo dof
            bdryCorrectionMatrix_[iVeloDof] = x_DofsCorrectionValue;
            // Output::print("Horizontal velo dof ", iVeloDof, " in Cell ",
            //              iCells, " put correction to ",
            //              horizontalDofsCorrectionValue);
            // this is a vertical (y-direction) velo dof
            bdryCorrectionMatrix_[velocity_space->get_n_dof() + iVeloDof]
                = y_DofsCorrectionValue;
            bdryCorrectionMatrix_[2 * velocity_space->get_n_dof() + iVeloDof]
                = z_DofsCorrectionValue;
          } // end loop over velocity dofs
        }   // end if dirichlet boundary
      }     // end if boundary joint
    }       // end loop over joints
  }         // end loop over cells

  // to store the correct matrix "H^{-1}= D*D_Q^{-1}" we have to scale with the
  // diagonal mass inverse
  std::transform(bdryCorrectionMatrix_.begin(), bdryCorrectionMatrix_.end(),
                 inverse_diagonal.begin(), bdryCorrectionMatrix_.begin(),
                 std::multiplies<double>());
}

#endif // 3D

void Saddle_point_preconditioner::computePoissonMatrixBdry(
  bool additive_storage)
{
  if(this->spp_type == Saddle_point_preconditioner::type::bd_lsc)
  {
    bool transpose;
#ifdef _MPI
    ErrThrow("Boundary Corrected LSC is not yet implemented for MPI.")
        const TParFECommunicator3D* u_comm
        = M->get_communicators()[0];
    const TParFECommunicator3D* p_comm = M->get_communicators()[3];
    std::vector<const TParFECommunicator3D*> test_comms = {p_comm};
    std::vector<const TParFECommunicator3D*> ansatz_comms
        = {u_comm, u_comm, u_comm};
#else
    // avoid compiler warning
    (void)additive_storage;
#endif
    TMatrix* ret = divergence_block->multiply_with_transpose_from_right(
        bdryCorrectionMatrix_,
        Poisson_solver_matrix->get_block(0, 0, transpose)->GetStructure()
#ifdef _MPI
            ,
        test_comms, ansatz_comms, additive_storage
#endif
    );

    poissonMatrixBdry_.reset(ret);
  }
  else
    ErrThrow("Call of Saddle_point_preconditioner::setUpPoissonSolverBdry() "
             "for wrong preconditioner.");
}
/* End extra methods for boundary corrected LSC */

/* Start extra methods for augmented Lagrangian based preconditioner */
/* ################################################################# */

/* **************************************************************** */
void Saddle_point_preconditioner::fill_AL_weight_W()
{
  // number of entries on diagonal in pressure_block
  size_t n_diagonal_entries_pressure_block
      = this->pressure_block.get_n_total_rows();

  this->scaled_inverse_diagonal_of_W.resize(n_diagonal_entries_pressure_block,
                                            0.);
  this->diagonal_of_W.resize(n_diagonal_entries_pressure_block, 0.);

  // matrix W and its approximation
  int use_lumped_pressure_mass = 0;
  // number of entries on diagonal in mass matrix
  for(unsigned int d = 0; d < n_diagonal_entries_pressure_block; d++)
  {
    if(use_lumped_pressure_mass)
    {
      Output::print<1>("Started to compute lumped pressure mass matrix for "
                       "Augm. Lagr. prec.");
      double row_sum_pressure_mass = 0.;
      for(auto j = 0u; j < n_diagonal_entries_pressure_block; j++)
      {
        row_sum_pressure_mass += pressure_mass.get(d, j);
      }
      // ToDo Write a routine which computes the scaled_inverse_diagonal_of_W
      // using the CRS
      this->scaled_inverse_diagonal_of_W[d]
          = this->gamma * (1.0 / row_sum_pressure_mass);
      this->diagonal_of_W[d] = row_sum_pressure_mass;
    }
    else
    {
      Output::print<1>("Started to compute diagonal of pressure mass matrix "
                       "for Augm. Lagr. prec.");
      this->scaled_inverse_diagonal_of_W[d]
          = this->gamma * (1.0 / pressure_mass.get(d, d));
      this->diagonal_of_W[d] = this->pressure_mass.get(d, d);
    }
  }
}

/* **************************************************************** */
void Saddle_point_preconditioner::fill_augmented_matrix_and_rhs()
{
  Output::print<1>(
      "Started to fill augmented matrix and rhs for Augm. Lagr. prec.");
  size_t n_rows = this->M->get_n_cell_rows(); // number of block rows

  std::vector<std::shared_ptr<const TMatrix>> aug_blocks;
  aug_blocks.resize((n_rows - 1) * (n_rows - 1));

  // form the blocks B_i^T*W^{-1}*B_j
  std::shared_ptr<const FEMatrix> grad_block_M, div_block_M;
  bool transp;

  this->augmented_matrix = BlockMatrix(
      M->BlockMatrix::get_sub_blockmatrix({0, 0}, {n_rows - 1, n_rows - 1}));

  if(this->spp_type == Saddle_point_preconditioner::type::mod_AL)
  {
    for(unsigned long block_col = 0; block_col < n_rows - 1; block_col++)
    {
      div_block_M = M->get_block(n_rows - 1, block_col,
                                 transp); // B1 or B2 or B3 (in 3D)

      for(unsigned long block_row = 0; block_row < n_rows - 1; block_row++)
      {
        grad_block_M = M->get_block(block_row, n_rows - 1, transp);
        std::shared_ptr<TMatrix> aux_ptr(grad_block_M->multiply(
            div_block_M.get(), this->scaled_inverse_diagonal_of_W));
        Output::print<1>("Started add_scaled() for augmented matrix for Augm. "
                         "Lagr. prec.; n_rows: ",
                         n_rows, "; current row: ", block_row + 1);
        if(block_row <= block_col)
        {
          aux_ptr->add_scaled(
              *M->BlockMatrix::get_block(block_row, block_col, transp), 1.);
        }
        else
        {
          aux_ptr->reset();
        }
        aug_blocks[block_col * (n_rows - 1) + block_row] = aux_ptr;

        this->augmented_matrix.replace_blocks(
            *aug_blocks[block_col * (n_rows - 1) + block_row],
            {{block_row, block_col}}, {false});
      }
    }
  }
  else if(this->spp_type == Saddle_point_preconditioner::type::AL)
  {
    for(unsigned long block_col = 0; block_col < n_rows - 1; block_col++)
    {
      div_block_M = M->get_block(n_rows - 1, block_col,
                                 transp); // B1 or B2 or B3 (in 3D)

      // Test
      // div_block_M->Print(divblock);
      // cout << "Norm of divblock: "<< div_block_M->GetNorm() <<endl;

      for(unsigned long block_row = 0; block_row < n_rows - 1; block_row++)
      {
        grad_block_M = M->get_block(block_row, n_rows - 1, transp);
        std::shared_ptr<TMatrix> aux_ptr(grad_block_M->multiply(
            div_block_M.get(), this->scaled_inverse_diagonal_of_W));
        Output::print<1>("Started add_scaled() for augmented matrix for Augm. "
                         "Lagr. prec.; n_rows: ",
                         n_rows, "current row: ", block_row + 1);
        aux_ptr->add_scaled(
            *M->BlockMatrix::get_block(block_row, block_col, transp), 1.);

        aug_blocks[block_col * (n_rows - 1) + block_row] = aux_ptr;

        this->augmented_matrix.replace_blocks(
            *aug_blocks[block_col * (n_rows - 1) + block_row],
            {{block_row, block_col}}, {false});
      }
    }
  }

  Output::print<1>(
      "Computation of augmented matrix for Augm. Lagr. prec. -- DONE");

  std::shared_ptr<TStructure> Structure = std::make_shared<TStructure>(
      pressure_mass.get_combined_matrix()->GetStructure());
  // cout<< "N_entries in pressure_mass: "<<
  // pressure_mass.get_combined_matrix()->GetStructure().get_n_entries() << endl;
  std::shared_ptr<TMatrix> ptr_to_diag_matrix = std::make_shared<TMatrix>(
      this->scaled_inverse_diagonal_of_W, Structure);

  std::vector<std::shared_ptr<TMatrix>> aug_blocks_for_rhs;
  aug_blocks_for_rhs.resize((n_rows));

  // form the matrices gamma*B_i^TW^{-1} for the augmentation of the rhs
  for(auto block_row = 0u; block_row < n_rows - 1; block_row++)
  {
    grad_block_M = M->get_block(block_row, n_rows - 1, transp);

    /*TMatrix* test = grad_block_M->multiply(ptr_to_diag_matrix.get(), 1);
    int vas1 = test->get_n_columns();
    int vas2 = test->get_n_rows();
    cout<< "************* : " << vas1 << "    "<<vas2 << endl;
     */

    std::shared_ptr<TMatrix> aux_ptr_for_rhs(
        (grad_block_M->multiply(ptr_to_diag_matrix.get(), 1)));
    aug_blocks_for_rhs[block_row] = aux_ptr_for_rhs;
  }

  // set the last block equal to zero
  std::shared_ptr<TMatrix> aux_ptr_for_rhs(
      (grad_block_M->multiply(ptr_to_diag_matrix.get(), 0)));
  aug_blocks_for_rhs[n_rows - 1] = aux_ptr_for_rhs;

  this->augmentation_matrix_for_rhs
      = BlockMatrix(n_rows, 1, aug_blocks_for_rhs);
  Output::print<1>(
      "Computation of augmentation of rhs for Augm. Lagr. prec. -- DONE");
}

/* **************************************************************** */
BlockVector Saddle_point_preconditioner::get_augmented_blockvector(
    const BlockVector& right_hand_side)
{
  BlockVector aug_right_hand_side(right_hand_side); // BlockVector(this->M);
  const double* g = right_hand_side.block(2);
  bool transp2;
  for(auto k = 0u; k < right_hand_side.n_blocks(); k++)
  {
    std::shared_ptr<const TMatrix> ptr_to_aug_blocks
        = this->augmentation_matrix_for_rhs.get_block(k, 0, transp2);
    ptr_to_aug_blocks->multiply(g, aug_right_hand_side.block(k), 1.);
  }
  return aug_right_hand_side;
}
/* End extra methods for augmented Lagrangian based preconditioner */
